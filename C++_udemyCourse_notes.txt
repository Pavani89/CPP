variable is an abstraction for a memory location

int age {21}; //c++11 list initialization syntax

primitive data types

Character type
char - one byte - 8 bits
char16_t - atleast 16 bits
char32_t - atleast 32 bits
wchar_t - can represent the largest available character set.

char middle_initial {'R'};  // '' is only accepted
string name {"Pavani"} // "" is only accepted

Integer type
signed/unsigned short int - Atleast 16 bits
signed/unsigned int - Atleast 16 bits
signed/unsigned long int - Atleast 32 bits
signed/unsigned long long int - Atleast 64 bits

long long people_on_earth{7'600'000'00'}; //the ticks are accepted in C++ 14 and ignored by compiler

size_t is normally a synonym for unsigned int. Its size depends on your compilers/architecture just like any other type such as int, long, float, etc.

Floating-point type:
float 
double
long double

Boolean type:
True - False - 8 bits  // output = 1 or 0

to switch to True or False
cout << std::boolalpha;
cout << (num1 == num2) << endl;  //true or false
cout << std::noboolalpha; // back to 0 or 1

true - 1
false - 0
=================================================================================================================
sizeof()   //climits and cfloat are the preprocessors that help get the data
return value is in bytes

user defined values in climits // vary from one host to another
=================================================================================================================
constants:
immutable variables. cannot be changed

TYPES:
Literal:
eg x = 12
\n
\t
\\

Declared constants
const keyword
eg const double pi {3.1415926} 

Constant expression
constexpr keyword
The constexpr specifier declares that it is possible to evaluate the value of the function or variable at compile time.

Enumerated constants
enum keyword

Defined constants
#define
eg #define pi 3.1415926

NOTE: Do not use defined constants in Modern C++  since this is a blind find replace. Not recommended
Preproccer would blindly replace as it does not understand C++. only compiler does
Use declare constants instead
=================================================================================================================
Arrays:

NOTE:old, modern C++ use vectors

Arrays are compound data type or data structure (collection of elements)
All elements are of the same type
can be accessed directly

C++ treats an array name as the location in memory of first array element

characteristics:
fixed sizeofstored contiguously in memory
first element in index 0
last - size - 1

initialization:
Element_Type array_name [element_index] {}; //elements = element_index - 1
or
Element_Type array_name [] {1,2,3}; //3 elements

Multidimension Array:
Element_Type array_name [dim1_size][dim2_size];
int movie_rating [3][4];

movie_rating[2][3] = 9;

out of bound array generates garbage data
=================================================================================================================
Vectors:
Dynamic size arrays
container in the C++ standard Template Library
grow/shrink at execution time
inbuilt functions to sort, reverse, find and more

#include <vector>
using namespace std;

vector <char> vowels;
vector <int> test_scores;

or initialization using constructor initilization syntax
vector <char> vowels (5); 
vector <int> test_scores (10);

initiazing:
vector <char> vowels {'a', 'e', 'i', 'o', 'u'};
vector <int> test_scores {100, 98, 95, 99};
vector <double> hi_temperatures (365. 80.0); // 365 is the size of the array, 80.0 is the initialised vaule for all the 365 doubles

NOTE: [] -> no checking to see if you are out of bound

accessing vectors:
test_scores[2];  // 95
or
test_scores.at(2); // 95 more intuitive syntax


assignment statement
test_scores.at(2) = 90;

Add new element to end of the vector
vector.name.push_back(element) //element must be same type
NOTE: vector will take care of automatically allocate the needed space

test_scores.size() //size of the vector


int score_to_add {0};
cin >> score_to_add;
test_scores.push_back(score_to_add); //user variables to enter to the vector

2D Vectors:
vector <vector<int>> movie_ratings 
{   
    {1, 2, 3, 4},
    {1, 2, 4, 4},
    {1, 3, 4, 5}
};

cout << movie_ratings.at(0).at(0) << endl;
cout << vector_2d.at(0).at(0) << " " << vector_2d.at(0).at(1) << endl;
=================================================================================================================
Operations:

; -> Null statment

	lhs = rhs
rhs is an expression that is evaluated to a value, the value of the rhs is stored to the lhs.
	
C++ is statically typed i.e. the compiler will be checking to see if it makes type of variable make sense to store
the value on right hand side to the left hand side

Increment operator ++
Decrement operator --

Prefix ++num  
Postfix num++

c = ++num //c = num + 1
c= num++  //c = num


Mixed Type expresssions
int a {100};
int b {0};
double avg {0.0};

avg = b/a; // avg = 12 //data loss even though double
avg = (double) b/a;  // avg = 12.5  // old fashon, does not check and overides the result to cast
avg = static_cast<double> b/a;  // avg = 12.5  //use this

<=> (C++20) -> three way comparision


Logical operator can use keywords - not, and, or - but not seen in common code, use the operators !, &&, ||
e.g:  num1 >= 10 && num1 < 20

operator precedence -> check notes or https://en.cppreference.com/w/cpp/language/operator_precedence
========================================================================================================================
Control statemnt:

if - else if - else:

if (){
	...
}
else if (){
	...
}
else{
	...
}

## to set precision or rounding
#include <iomanip>
cout << fixed << setprecision(2); // prints dollars nicely

switch statement:

switch(expression){
case '1': statement;
		break;
case '3':
case '2':
		statement;
		break;
case '5': statement;
		break;
default: "Always executes; is optional but good practice to include"
}

NOTE: swicth commonly used with enumeration

conditional Operator:
(cond_expr) ? expr1 : expr2

eg: cout << num << " is " << ((num%2 == 0) ? "even" : "odd") << endl;
========================================================================================================================
for loop
for (initialization ; condition ; increment){
	statement(s);
}

C++ 11 introduced
Range-based for loop  //auto iterate , good for vectors
for (var_type var_name: sequence){
	statement(s);
}
eg:
for (auto val: {1,2,3,4,5})
    cout << val << endl;

while loop  //condition evaluated before executing
while (expression){
	statement(s);
}
NOTE: commonly used for input validation
KISS - keep it simple silly

do-while loop  //expression checked in the end  - common menu driven program
do {
	statements;
} while (expression);
========================================================================================================================
Characters and Strings:
=======================

#include <cctype>  //for character based functions

such as
isalpha(c)
isalnum(c)
islower(c)
ispunct(c)
isspace(c)

tolower(c)
toupper(c)

C-Style Strings:
----------------
ended with null (take 1 byte extra to append null)

eg. of C-Style: char my_name[] {"Pavani"};

#include <cstring> // to work with C-Style Strings

strcpy(my_name, "Rohan"); //copy
strcat(str, "there") //concatenate
strlen(str) //length of string
strcmp(str, str2) //compare per character //0 - equal; <0 - str1 greater; >0 -> str2 greater

NOTE: Many issues if the string is not null terminated. Hence solution is C++ Strings

#include <cstdlib> //general purpose functions to convert C-Style Stings to int, float,long etc

NOTE: strlen returns a size_t (unsigned int/long)

NOTE: cin.getline(full_name, 50); //all inputs from keyboard or max of 50 or untill enter hit

C++ Strings:
------------
std:string is Standard Template Library Class
#include <string>
contiguously memory, dynamic, wotk with string IO Streams

eg: string s1; //Empty , not garbage.
s1 = "C++"; //C++ //assignment
string s1 {"Pavani"}; // Pavani
string s2 {"Pavani", 3}; //Pav
string s3 {"Pavani", 0, 2}; //Pa
string s4 (3, 'X'); //XXX

s1 + s2 // concatenation

Accessing characters [] or at()

== != > >= < <= //can be used to compare strings

substr() //Extract sub string
eg: s1.substr(0,4);

find()  //returns index of the substring
npos -> returned if string not found
eg: 
string word {" This is Sparta};
size_t position = word.find(is);
if (position != string::npos){
	cout << "Found!"
}

erase(); Clear() to remove charaters

s.length() //length of string

getline(cin, var_name) //NOTE: signature is different from C-Style

//substring
unformatted_full_name.substr(0,7)
========================================================================================================================
C++ Functions:
===============
c++ has many predefined library with global functions

eg:
<cmath>
sqrt, pow 

<cstdlib>
rand // random numbner generator

Function parameters:
In the function definition they are called parameters    // int sum(int, int);            
In the function call they are called arguments           // int sum(int a, int b){...}


Pass-by-Value: (default)
A copy of the data is passed to the function (so needs space and time)
any changes to the parameters in the function does NOT affect the argument that was passed in.

Formal vs Actual parameters:
Formal - params definded in the function header
Actual - params used in the function call, the arguments


default argument value - good practice to provide in function prototype/header


NOTE: Arrays passed to function, replace the values in the array if edited within the function
as the arrays are memory location and this updates the array

NOTE: Adding const to array in read only functions. This helps to unedit the values by mistake 

Pass-by-Reference:
acheived by location or address of the actual parameter. by passing &
since it uses the address location(does not copy variable, it is faster)


static variable - it is a gobal variable local to a function

function call stack - Last In First Out
push and pop

inline function: by default compiler treats functions inline which helps ease the space, stack manamagemnt.
inline int add(int a, int b) {
	return a + b;
}
https://cplusplus.com/articles/G3wTURfi/


recursive functions:
function that directly or indirectly calls itself.
make sure there is a base case to exit the recursive case
========================================================================================================================
Pointers and References:
* helps edit some assemblies on the device

Pointer is a variable whose value is an address of another variable or function.
pointers are read right to left

variable_type *pointer_name {nullptr}; //needs to be initilised to 'point nowhere' -> null pointer

int *int_ptr  {nullptr};

& the address operator;  

size of pointer irrespective of the variable it points // default is 4 bytes 

dereference a pointer:
Dereferencing is getting at the pointed value. Pointer variables are useful for walking the contents of a linked list data structure, using a dynamic jump table to subroutines, and passing arguments by address (so only an address is passed) rather than by value (where the entire data structure is copied)
eg:
int score {100};
int *score_ptr {&score};

cout << *score_ptr; // 100 //will display the value of the variable which is in the adress stored (lvalue) in the pointer

Dynamic memory Allocation:
 with new keyword
use delete [] var; // to release the heap memory 

pointer increment/decrement:
int_ptr++;  //increments pointer to point to next array element
int_ptr--;  //decrements pointer to point to previous array element

const + pointers
1. pointers to constants i.e. The data pointed by the pointers is constant and connot be changed
const int *score_ptr {&score1};

*score_ptr = 66; //ERROR
score_ptr = &score2;  // OK as we are changing the pointer references

2. constant pointers i.e. The pointer itself cannot be changed and pointed elsewhere
int const *score_ptr {&score1};

*score_ptr = 66; // OK as we are changing the value of the variable in the pointer loc
score_ptr = &score2;  // ERROR

3. constant pointer to constants i.e data pointer by the pointer and the pointer itself cannot change
const int const *score_ptr {&score1};

*score_ptr = 66; // ERROR
score_ptr = &score2;  // ERROR

function returning pointers:
type *function();

Should return pointers to 
 * Memory dynamically allocated in the function
 * To data that was passed in

l-values and r-values:
l-values - values that have names and are addressable or follow a pointer to get to the object, modifiable if not constants
int x {100};
string name;
name = "Pavani"

x and name are lvalue
values on left side of assignment expression

rvalues - right side of assignment, literal, temporary which is intended to be non-modified
temporary objects created by the compiler (return from methods)

100, "Pavani" are r-values.
========================================================================================================================
Object-Oriented Programming:

procedural progarmming - common programming - typicallt collection of functions

OOPS focus on clasess and objects

classes are blueprint from which objects are created
user-defined data-type has attributes, methods, hide data and methods, provide public interface
eg: std::vector, Account, std::string

objects created from class, specific instance of a class, has its own identitity and use defined class methods
eg: won balance, credir, withdrawals etc

class Player
{
	// attributes
	std::string name;
	int health {100};
	int xp {3};
	
	// methods
	void talk(std::string text_to_say);
	bool is_good();
};


// Objects
Player frank;
Player hero;
 
// or pointer to objects
Player *enemy = new Player();
delete enemy;

// vector 
vector<Player> player_vec{frank};
player_vec.push_back(hero);
--------------------------------------
Accessing memeber class:

dot opertor:
Player two;
two.name = "Pavani"
two.talk("Hi!");

dot operator with pointers:
Player *three = new Player();
(*three).talk("Hi1");

OR
Arrow operator()
three->talk("Hi!";)
---------------------------------------
Class memeber access modifiers:
public, priavte and protected

public - access everywhere
private (default) - accessible only by memebers or friends of the class
protected - with inheritence

class Class_Name
{
	public:
		// declarations(s)
};
---------------------------------------
Member methods: (getters and setters)
class Account {
private:
    string name;
    double balance;
    
public:
    // declared inline
    void set_balance(double bal) { balance = bal; }
    double get_balance() { return balance; }
    
    // methods will be declared outside the class declaration
    void set_name(string n);
    string get_name();
    
    bool deposit(double amount);
    bool withdraw(double amount);
};

void Account::set_name(string n) {
    name = n;
}

Here :: are called scope resolution operator
As the methods are declared outside the Class definiton. we prefix the classname with the scope resolution operator

Include Guards (X -> class/file name)

#ifded _X_H_
#define _X_H_
	// Account class declarations
#endif

#pragma once // same as include guard, but it depends on the compiler


#include <stdio>  // System header files, where the system know of the location
#include "Account.h"   //indicate these are custom file, system will know where to find.

-----------------------------------------
Contructors and destructors:

Player();
Player(std::string name);
Player(std::string name, int health, int xp);

destructors - 
~Class_Name
useful to release memory and other resources
no overloading destructors
called automatically

~Player();  //No return type or parameters
--------------------------------------------
Overloading constructor:

multiple supportedwith unique signatures

Player();
Player(std::string name) {health = 0; xp = 0;};   
	// Alternate and better way using constuctor initi Lists - Player::Player()
							: name{"None"}, health{0}, xp {0}{
						}
Player(std::string name, int health, int xp);
---------------------------------------------
Delegating Contructors:
// more optimised solution to the above example
	Player::Player()
	: Player {"None", 0, 0} {
	}
---------------------------------------------
Contructor Parameters and Default Values:

// Ultimate solution to reduce duplicate code and errors - Default Constructor parameters

Player::Player(std::string name_val, int health_val, int xp_val)
	: name {name_val}, health {health_val}, xp {xp_val} {
	...
	}

Player empty;  //None, 0 , 0
Player Pavani {"Pavani"}; // Pavani, 0 , 0 
Player villian {"Villian", 100, 33]; /Villian, 100, 55
---------------------------------------------------------
copy constructor:
used to create a new object from an exisitng object

Type::Type (const Type &source);

Player::Player (const Player &source);
---------------------------------------------------------
Shallow vs. Deep copying

* consider a class with pointer as data member
* contructor allocates dynamic storage and initialises the pointer
* Destructor releases memory allocated by constuctor
What happens when the default copy contructor? (used above section)

Shallow copy:
* default
* memberwise copy of the all tbe object attributes so  end up with the newly created object,
and the object being copied both pointing to the same area of storage in the heap.

The problem comes into play when one of those objects is destroyed and its destructor is called.
To avoid, use deep copy

Deep copy:
With a deep copy, we don't just simply copy the pointer. Instead, we copy the data pointed to by the pointer.
Each copy will unique storage in heap.
Use Deep copy  when you have a raw  pointers in memeber class

definition of the copy contructor or delegating contructor excplict call for new heap memory (new for copy constructor)

Check codelite for code
---------------------------------------------------------
Move Constructor: (need to revisit)
----------------
R-value references objects are the objects that move semantics addresses.

We also know that if our class contains a raw pointer,then we must implement deep copy.
However, this can be computationally expensive since we have to allocate space for the copy and then copy the data over.
The c++ move constructor moves the object rather than copies it, this can be extremely efficient.

Copy illusion is a compiler optimization technique that eliminates unnecessary copying.
that's when the compiler generates code that doesn't create a copy every return value from a function making the code much more efficient.

L-value reference operator - & (already understood)
R-value reference opertaot - &&
---------------------------------------------------------
this keyword:
this->memeberName = smilarname memeber
---------------------------------------------------------
static Class members:

class data members (variables and functions) can be declared static (not the object)
Static functions can only access static class variables, not object variables
---------------------------------------------------------
struct vs classes:
The struct comes from the c programming language.
Much like a record in many other programming languages - C++ also supports struct since it has to be compatible with c.
However, it adds the ability to treat structs very much like classes.

The only difference is that the members of the structs are public by default.
Whereas, the members of a class are private by default.
========================================================================================================================
Opertor overloading:
--------------------

overloading the copy assignment operator(deep copy semantics)
// similar to copy constructor, it perfroms memberwise copy. pointer variables could lead to issues at run time.
Type &Type::operator=(const Type &var);   //= operator being over loaded


overloading the move assignment operator
// for temporary variable vlaues - &&rhs
Type &Type::operator=(const Type &&var);   //= operator being over loaded

<not completed>
========================================================================================================================
Inheritance:
-------------

inheritance is the process of creating new classes from existing classes.
It's a mechanism that allows us to reuse existing code.

single inheritance: we create a new class based on another single class.

Multiple inheritance: is when we create a new class from two or more other classes.

base class and derived class

"Is-A" relationship: public inheritance, derived classes are sub-types of their Base classes

Generalization: Combining similar classes into a single class

Specialization: is the opposite of generalization.This is about creating new classes from existing classes and these new classes generally add attributes and operations

Inheritance hierarchies: Organization of our inheritance relationships

Syntax:
class Base{
	// Base class members...
}

class Derived: access-specifier Base{
	// Derived class memebers ...
}

access-specifier can be: public, private or protected

composition:
"has-a" relationship


in a derived class, to call the base class overloaded constructor use //- using Base::Base;

Derived(): Base{}, double_value{0}{
	cout << "" < endl;
}
========================================================================================================================
Polymorphism:
=============
types:
compile time/early binding/static binding [default] - overloaded functions and overloaded operators. (They simply mean before the program executes. i.e  the compiler takes care of way before the program runs.)
run-time /late binding /dynamic binding - Function overridding. being able tyo assign different meaning to the same function at run time ( what the programmer wants to do with how to do it but at runtime as the program executes.)
can be acheived by inheritance, base class pointers and references, virtual functions

Virtual functions:
--------------------
Redefined functions are bound statically while overidden function are bound dynamically
Virtual functions are overriden 


virtual void function () [in Base class]
virtual keyword in the dereived class is needed for  best practice

"override" keyword is needed to make sure the function 


virtual destructors:
--------------------
needs to be used with virtual function
virtual ~Class();

override keyword:
-------------------
C++ 11 provides override specifier to over ride Base class virtual functions
The fucntion signature and return must be EXACTLY the same

virtual void say_hello() overidde {

}

========================================
Base *p1 = new Derived();
pointer p1 is a pointer to the Base object but is instantiated to Derived object
========================================
C++ 11 Final specifier
---------------------------
At Class level: prevents a class from being derived from or subclassed.  Other times, it may be done to ensure that objects are copied safely without slicing.
At method level: prevent virtual methods from being overidden in derived class
In some cases, used for better compiler optimization.

class My_class final {
	...
};

class Derived final: public Base {
	...
};


BaseClass reference object in dynamic overide:
---------------------------------------------------
Derived d;
Base &ref = d;

ref.say_hello()  // Derived::say_hello()

virtual function and abstract classes:
---------------------------------------
Concrete classes -
All of their member functions must be defined.

Abstract classes -
An abstract class is a class that cannot be instantiated.
Well, abstract classes are used as base classes in inheritance hierarchies.And they're often referred to as abstract based classes.
and it must contain at least one pure virtual function.

Pure virtual function:
------------------------
We declare pure virtual functions, just like virtual functions, but we add the equal 0 after the prototype.
virtual void function() = 0;  //pure virtual function

Abstract classes as interfaces:
-------------------------------
An interface class in c++ is a class that has only pure virtual functions. These functions provide a general set of services that users of the class can use.
In order to be useful, these pure virtual functions must be declared as public.

Any class that wants to be a concrete class and support the interface provided by the interface class can override the pure virtual functions and implement these services as needed.


No exact keyword for interface in C++ but it can be acheived with a abstract class and pure virtual function.
========================================================================================================================
smart pointers: introduced in C++11
---------------
must need in modern CPP

issues with raw pointers:
--------------------------
Need to be initialized and released
Memory leaks
wild pointers
Dangling pointers
Not exception safe

smart pointers are objects. In fact, smart pointers are implemented as c++ template classes, which we can instantiate.
Smart pointers can only point to heap allocated memory, and they automatically call delete when that's no longer needed.
Also very importantly, smart pointers adhere to RAII principles.

types:
unique pointer, shared pointer, weak pointer and auto pointer.
Auto pointer has been deprecated so you shouldn't use this going forward.

First, we need to include the memory header file since it defines the smart pointer --> #include <memory>

Smart pointers are basically wrapper classes that contain and manage a raw pointer.
Overloaded opertaors
(*) dereference
(->) member selection
pointer arithmetic not supported (++, --, etc)
can have custom deleters

simple example:
----------------
std::smart_pointer<unique/shared/..> ptr = ...;
prt->method();
cout << (ptr*) << endl;
// No dlete, the ptr will be destroyed automatically.


RAII - Resource Acquisition Is Initialization
RAII objects are allocated on the stack

Resouece Acquisition i.e opening a file, allocating memory, acquiring a lock and so forth.
Is Initialization means that the resource is acquired at object initialization time. So in other words, it happens in the object's constructor.
resouece Relinquish -> happens in the destructor. Here we can close the file, de-allocate any allocated memory,release locks and so forth.

Unique pointers:
----------------
----------------
----------------
Simple smart pointer - very efficient


unique_ptr<T>
points ro an object of Type T on the heap
There can only be one unique_ptr pointing to the object on the heap
it owns what it points to
Cannot be assigned or copy
CAN be moved
Automatically destroyed

unique_ptr e.g. 
std::unique_ptr<int> p1 {new int {100}};
std::cout << *p1 << std::endl;   //100
*p1 = 200;
std::cout << *p1 << std::endl;   //200
// automatically deleted


unique_ptr - some other useful methods:
------------------------------------------
std::unique_ptr<int> p1 {new int {100}};
std::cout << p1.get() << std::endl;   //0x54569

p1.reset()  //p1 is now nullptr

if(p1)
	std::cout << *p1 << std::endl;   // won't execute
// automatically deleted


unique_ptr - vectors - copy and move:
---------------------------------------
std::vector<std::unique_ptr<int>> vec;
std::unique_ptr<int> ptr {new int {100}};

vec.push_back(ptr);  //Error - copy not allowed

vec.push_back(std::move(ptr));  // the ownership changed to the vector
// Automatically deleted

unique_ptr - make_unique (c++14): [preferred way]
----------------------------------
Since c++14, we can use the make unique function. This function returns a unique pointer of the specified type, and it allows us to pass initialization values
into the constructor for the manage object.

std::unique_ptr<int> p1 = make_unique<int> (100);    // no new keyword used to initialize the ptr p1
std::unique_ptr<Account> p2 = make_unique<Account> ( "Curly", 5000);   //Another way to initialize
auto p3 = make_unique<Player> ("Hero", 100, 100);   // Another way to initialize


Shared pointers:
----------------
----------------
----------------
So like a unique pointer, a shared pointer points to an object on the heap. unlike a unique pointer, that heap object may be shared among many shared pointers.
Unlike unique pointers, shared pointers can be copied and assigned. This is exactly how we make them access the same heap object.
For efficiency, shared pointers also support move semantics.
 
Destroy pointer- 
The most common technique is to use reference counting. The idea is simple.
Every time we instantiate a shared pointer object and have it point or reference to the heap object, we increment the counter.
This counter simply has the number of shared pointers referencing that heap object.
When the reference goes zero, delete the poointer

This introduces a overhead in the process but is not abig deal compared to the benefits

shared_ptr example:
-------------------- 
std::shared_ptr<int> p1 {new int {100}};
std::cout << *p1 << std::endl;   //100
*p1 = 200;
std::cout << *p1 << std::endl;   //200
// automatically deleted

shared_ptr - some other useful methods:
------------------------------------------
// use_count - returns the number of shared pointer objects that are currently referring to the heap object.

std::shared_ptr<int> p1 {new int {100}};
std::cout << p1.use_count() << std::endl;   //1

std::shared_ptr<int> p2 {p1};  //copy constructor  // shared ownership
std::cout << p1.use_count() << std::endl;   //2

p1.reset()  //drecrement the use_count; p1 is now nullptr

std::cout << p1.use_count() << std::endl;   //0 //So just because we reset p1 doesn't mean that we de-allocate the integer on the heap.
std::cout << p2.use_count() << std::endl;   //1 
// automatically deleted

shared_ptr - vectors - copy and move:
---------------------------------------
std::vector<std::shared_ptr<int>> vec;
std::shared_ptr<int> ptr {new int {100}};

vec.push_back(ptr);  //OK - copy IS allowed

std::cout << ptr.use_count() << std::endl;  // 2

vec.push_back(std::move(ptr));  // the ownership changed to the vector
// Automatically deleted

shared_ptr - make_shared (c++11): [preferred way]
----------------------------------
introduced in C++ 11
std::make_shared -  more efficient

std::shared_ptr<int> p1 = std::make_shared<int> (100);    // no new keyword used to initialize the ptr p1   //use_count = 1
std::shared_ptr<int> p2  {p1};   //use_count = 2
std::shared_ptr<int> p3;   //null pointers

p3 = p1;   // use_count = 3

// automatically deleted

weak pointer:
--------------
--------------
--------------
weak_ptr
provides a non-owning "weak" reference. Like a shared pointer, a weak pointer points to an object on the heap. But unlike a shared pointer, it doesn't participate in the owning relationship.
Weak pointers are always created from shared pointers.
And since weak pointers are non-owning references, they do not affect the reference count for the managed object.So weak pointers don't affect the lifetime of the objects they're pointing to.

does NOT increment or decrement referece use count

There are a few use cases for the weak pointer, one is to prevent strong reference cycles between two objects.
Another use case is when we have a pointer that we use to temporarily reference another object, something like an iterator pointer that traverses a list of nodes.

circular or cyclic reference
========================================================================================================================
Exception Handling:
=====================
* First, exceptions in c++ should be used only for synchronous code, not asynchronous code.
* Exception handling is about dealing with extraordinary situations. We want to be able to detect when an extraordinary situation has occurred or is about to occur so that we can deal with it.

exception causes -
* insufficient resource
* missing resouces
* invalid operations
* range violations
* underflows and overflows
* illeagal data

Exception - exception is an object or primitive type such as an int, a double, a Boolean and so forth. And it signals that an error condition has occurred.
In many cases, this exception object also contains information about what happened.

Throwing an exception (raising an exception) - 
When your code determines that something is wrong, then it can throw an exception object. Why can't the code just deal with the problem?
Well, in some cases it can, and it doesn't throw an exception, it just handles it itself. 
However, the more common use case is that the problem is detected in one place in your program, but that part of the program doesn't know what to do about it.
So it throws an exception in hopes that some other part of the program can deal with it.

Catching an exception (handle the exception) - 
In some cases, dealing with this simply means displaying or logging an error message and terminating the program
that's okay if the program can't continue, and we fail soft. In other cases, we may be able to handle the exception, recoever and continue processing.

throw
* throw an exception
* followed by an argument

try {put code that may throw exception} block
* if the code in the try block throws an exception, then the rest of the code in the block does not execute, and c++ looks for a block of code that can handle that thrown exception.

catch (Exception ex ) {code to handle exception}
Catch blocks only execute if an exception is thrown, and the type of the thrown exception matches the parameter in the catch block.

example:
try {
	if (total == 0)
		throw 0;     // throw the exception  //best practice to use objects not numbers
	average = x/y;
	}
	catch (int &ex){   // exception handler
		std::cerr << "cannot divide by zero" << std::endl;  
	}
	std::cout << "program continues" << std::endl;


Throwing an exception from functions:
---------------------------------------
caller of the function should capture the exception thrown

function x(){
	
	throw 0
	
}

main (){
	try{
		x();
	}
	catch (int ex){
		cout << "exception handled"
	}
}

Throwing and catching multiple exception :
---------------------------------------------
try {
	if (total == 0)
		throw 0;     // throw the exception  //best practice to use objects not numbers
		
	if ( x < 0 || y < 0)
		throw std::string{"Negative value"};
	average = x/y;
}
catch (int &ex){   // int exception handler
	std::cerr << "cannot divide by zero" << std::endl;  
}
catch (std::string &ex){   // string exception handler
	std::cerr << ex << std::endl;  
}
std::cout << "program continues" << std::endl;

OR
have a catch all handler
try {
	if (total == 0)
		throw 0;     // throw the exception  //best practice to use objects not numbers
		
	if ( x < 0 || y < 0)
		throw std::string{"Negative value"};
	average = x/y;
}
catch (int &ex){   // int exception handler
	std::cerr << "cannot divide by zero" << std::endl;  
}
catch (std::string &ex){   // string exception handler
	std::cerr << ex << std::endl;  
}
catch (...){   // catch all handler
	std::cerr << "Unknwon exception" << std::endl;  
}
std::cout << "program continues" << std::endl;

User defined exception classes:
--------------------------------
class DivideByZeroException{   //user defined exception class
};

try {
	if (total == 0)
		throw DivideByZeroException();     // throw the exception 
	average = x/y;
}
catch (const DivideByZeroException &ex){   // user defined exception handler
	std::cerr << "cannot divide by zero" << std::endl;  //can call class methods, constructor (without any return value)  if delclared
}
std::cout << "program continues" << std::endl;

NOTE: Do NOT throw exceptions from your destructor


std::exception class Hierarchy:
===============================
what()
noexpect() -> no throw exception

========================================================================================================================
Lambda functions:
=================


Background (prior to C++11)
Functors/ Function Objects:
---------------------------
https://www.youtube.com/watch?v=LbuC6XHhfbA

Introduced in C++ standards
The functor allows an instance/object of the class to be called/invoked as if it is an ordinary function.
It means the object of the class behaves as a function. This is acheived by overloading the opertor ().


class Test{
private:
	int a {};
public:
	// overloaded contructor
	Test(int a = 0) :a {a} {}
	//functor
	int operator()(int b, int c){
		return a + b + c;
	}
};

int main (){
	Test test(1); //test is object of Class Test
	std::cout << "Result: " << test(2, 3) << std::endl;  //functor 
	
	return 0;
}


example for lambda function:
--------------------
https://www.youtube.com/watch?v=EwLHcF5w4oU
https://www.youtube.com/watch?v=wd2LyLfvkVw

lamda - unamed/anonymous function
[] () ->return_type  specifiers{};
[] - capture closure
() - paramter list (optional)
{;} - method definition, logic
return_type - if return any, if void leave blank
specifers - mutable or constexpr
Exception - use "noexcept" to handle exception

#include <string>
#include <iostream>

int main() {
    
    auto add = [](auto x, auto y) { return x+y; };   // C++14
    int a {1},b {2};
    std::string str1 {"Test"}, str2 {" Finite"};
    
    std::cout << add (a, b) << std::endl;
    std::cout << add (str1, str2) << std::endl;
    
    return 0;
}


Stateless lambda list:
----------------------
does not have knowledge of the environrment for the function, only know the parameters passed to it
stateless is denoted by empty []

eg1:
[] () {std::cout << "Hi";} ();   // Displays Hi because it is invoked with ()

eg2:
int x {10};
[] (int x) {std::cout << x;}(100); //Displays 100


references and pointers, vectors ans structs -  can be passed as inputs to lambda



using lambads as function parameters:

#include <functional>

In C++ 14, method 1:
passing the lambda function as a functional object using std::function
void foo(std::function<void(int)> l){
	l(10);
}

In C++ 14, method 2:
as a function pointer
void foo (void (*l) (int)){
	l(10);
}

In C++20
we can  do away with declaring the return and parameter type
void foo (auto l)){
	l(10);
}

stateful lambada expresssions:
-------------------------------
premuch similar to stateless except it would have non-empty Capture List [captured_variables] i.e capture variables from it environment
captured_variables - defines what infromation/variables should be captured

eg1:
int y {10};
auto l = [y] (int y) {std::cout << y;}(); //Displays 100  

By default the value with in the lambda cannot be edited so, we need to use mutable
eg2: 
int x {100};

[x] () mutable {     // tell the compiler to generate the lambdas opertor fucntion as a non-const
	x += 100;
	std::cout << x;   // Displays 200
} ();

std::cout << x;  // Displays 100 

default captures:
[=] // default capture by value
[&] // default capture by reference
[this] // default capture by this object of reference

using default and explicit captures:
[=, &x] // default capture by value but capture x by reference
[&, y] // default capture by reference but capture y by value
[this, z] // default capture by this object of reference but capture z by value
========================================================================================================================
Temmplates:
============
https://www.youtube.com/watch?v=vUI5GvWexsM
Types: 
	function template
	class template
	variable template (C++ 14)

Templates are way to write generic programs.
The main point is we pass data type as parameter to function or class

using namespace std;
template<typename T>     // We may also use class instead of typename
T getMax(T x, T y){
	return x>y? x:y;
}

int main(){
	cout << getMax<int>(2, 4) << endl;
	cout << static_cast<char>(getMax<char>('a', 'x')) << endl; 
	
	return 0;
}

variable template:
#include <iostream>

using namespace std;
template <typename T>
T pi = T(3.145926535897932384626433L);   //variable template 

int main(){
	pi<char> = 'a';
	cout.precision(std::numeric_limits<long double>::max_digits10);
	std::cout << pi<int> << endl;   // values placed at compile time
	std::cout << pi<float> << endl;
	std::cout << pi<double> << endl;
	std::cout << pi<long double> << endl;
	std::cout << pi<char> << endl;
}

output:
3
3.14592647552490234375
3.14592653589793247448369584162719548
3.14592653589793247448369584162719548
a

Macros should be replaced by templates

A template is it generic blueprint that the compiler uses to generate specialized functions in classes.
The compiler generates the specific function or class that we need. NOT at RUN time

Types: 
	function template
	class template
	variable template (C++ 14)
========================================================================================================================
STL:
=====
The stl is a library of powerful, reusable, adaptable, generic classes and functions.
Implemented using C++ templates

Elements of STL:
----------------
Containers: collection of objects or primitive types (array, vector, deque, stack, set, maps, etc)
Algorithms: functions for processing sequences of elements from containers (find, max, count, accumulate, sort, etc)  60 Algorithms.
Iterators: generates sequences of element from containers (forward, reverse, by value, by reference, constant, etc)

some algorithms examples:
--------------------------
60 Algorithms.
classified into modifying and Non-modifying

std::sort(v.begin(), v.end());
std::reverse(v.begin(), v.end());
x = std::accumulate(v.begin(), v.end(), 0); //sum the vector  // 0 -> start value   // use 0 for int, 0.0 for float

Types of Containers:
--------------------
Sequence containers: array, vectir, list, forward_list, deque   // maintain the order of inserted elements
Associative containers: set, multi set, map, multi map  // insert elements in a predefined order or no order at all.
Container adapters: stack, queue, priority queue// variation of other containers, does not support iterators and cannot be used with stl algorithms // but are common used DS

Types of Iterators:
--------------------
Input iterators: make container elements available to your program.
Output iterators: can iterate over a sequence and write an element to a container.
Forward iterators: can iterate forward over a sequence and can read or write any element.
Bi-directional iterators: are like forward iterators, but they can iterate over a sequence in both directions.
Random access iterators: can use the subscript operator to directly access elements. We saw that with the vector class.


for_each algorithm applies a function to each element in the iterator sequence
We can use functors (function objects), function pointers and lambda expressions.
Functors and function pointers have been around since the beginning of the stl.
Lambda expressions were added in c++11

----------------------------------------------------------------------------------------------------------------
std::array - 
-------------
#include <array>
Element access happens in constant time
raw arrays accessible when needed


std::array<int, 5> arr {{1,2,3,4,5}};   //{{}}  needed in C++11 {}C++14 and above

arr.size() //5

arr.at(0);    // 1 //does boundary checking and throws exception.
arr[1]; //2 //accessible. but does not throw wexception when out of bounds

arr.front(); // 1
arr.back();   // 5

arr.empty();   //isempty?   // 0 (false)
arr.max_size(); // 5     //rarely used in array but mostly used in other containers

arr.swap(arr1);    //swaps the 2 arrays
int *data = arr.data() //get raw array address
----------------------------------------------------------------------------------------------------------------

std::vector - 
-------------
#include <vector>
dynamic size
expand and contract
vector is in contiguous memory
direct element access
rapid insertion and deletion at back(constant time)
insertion or removal of elements (linear time)
all iterators available and may invalidate (if size shrinks)


std::vector<int> vec {1,2,3,4,5}; 
std::vector<int> vec1 (10, 100);  // ten 100s  //notice the paras ans not braces..i.e. o verloaded constrctor of vector class

vec1 = {2, 3,4 ,5 ,6,10};

std::vector<std::string> stooges {
				std::string{"Larry"},
				"Moe",
				std::string{"Curly"};

vec.size()
vec.capacity()
vec.max_size;   // a very large number

vec.at(9); // at 8th indeex
vec[1]; // element at 1st index

vec.front(); //1
vec.back(); //5

vec.push_back(p1);
vec.pop_back();  /remove p1 from the back

vec.push_back(Person{"Larry", 18});

vec.emplace_back("Larry", 18);   // This method expects the parameters that would normally be passed into the person constructor. And that's what it does it constructs the person object using a person constructor right in place
where it's supposed to be in the vector.
very efficient

vec.empty()   //o (false)
vec1.swap(vec);
std::sort(vec.begin(), vec.end())

//find and insert into vectors
std::vector<int> vec {1,2,3,4,5};
std::vector<int> vec {10,20,30,40,50};
auto it =std::find(vec1.begin(), vec1.end(), 3) //find element 3
vec1.insert(it, 10 ) //1,2,10,4,5

similary one vector can be embedded into another
----------------------------------------------------------------------------------------------------------------

std::deque (spelt as desk) -
---------------------------
#include <deque>
The deque acts like a double-ended queue.

The deque size is dynamic, and it's handled by the stl so that's very much like a vector.
But unlike a vector, the elements in the deque are not stored in contiguous memory.

The deque allows direct element access using the subscript operator and the .at method. (constant time)

the deque allows efficient insertion and deletion at the back and at the front. (constant time)

However, inserting elements into any other part of the deque other than the front or back is not as efficient. (linear time)

all iterators available and may invalidate (if size shrinks)


std::deque - initialization and assignment

std::deque<int> d{1,2,3, 4, 5};

std::deque<int> d1 (10, 100);  // ten 100s  //notice the paras ans not braces..i.e. o verloaded constrctor of vector class

d = {2, 4, 5,6, 7};
std::deque<std::string> stooges {
				std::string{"Larry"},
				"Moe",
				std::string{"Curly"};

d.front(); //2
d.back(); //7

d.push_back(6);
d.pop_back();  /remove 6from the back

d.push_front(7);
d.pop_front();

d.size()
d.capacity()
d.max_size;   // a very large number

d.at(9); // at 8th indeex
d[1]; // element at 1st index

d.emplace_back("Larry", 18); 
d.emplace_front("Moe", 24); 

d.empty()   //o (false)
d1.swap(d);
std::sort(d.begin(), d.end())
----------------------------------------------------------------------------------------------------------------

std::list (forward_list and list) -
-------------------------------------
These are both sequence containers and store their elements in non-contiguous memory.
They don't provide direct access to elements via the .at method or subscript operator, but they're very efficient when we need to insert and delete elements in the list once an element is found.

list:
-----
std::list
#include <list>
The list acts as a doubly linked list of elements, so we can navigate forward and back.
The list has a front and a back, and we can use all of the iterators, but the iterators may become invalid when deleting elements.

std::list<int>  l{1,2,3};
the list allows efficient insertion and deletion at the back and at the front. (constant time)
Inserting and removing elements other than at the ends is very efficient, but in order to do that, we need to have an iterator to the element that we want to remove or insert before.

std::list<int> l (10, 100); 

1 = {2, 4, 5,6, 7};
std::list<std::string> stooges {
				std::string{"Larry"},
				"Moe",
				std::string{"Curly"};

l.size()
l.max_size;  

at and [] - not supported in list

l.front(); //2
l.back(); //7

l.push_back(6);
l.pop_back();  /remove 6from the back

l.push_front(7);
l.pop_front();

l.emplace_back("Larry", 18); 
l.emplace_front("Moe", 24); 

methods that use iterators:
std::list<int>  l{1,2,3,4,5};
auto it = std::find(l.begin(), l.end(), 3);
l.insert(it, 10);    // 1 2 10 3 4 5
l.erase(it);         // 1 2 10 4 5
l.resize(2);         // 1 2
l.resize(5);         // 1 2  0 0 0 

//traversing the list (bi-directional)
std::list<int>  l{1,2,3,4,5};
auto it = std::find(l.begin(), l.end(), 3);

std::cout << *it;  //3
it++; 
std::cout << *it;  //4
it--; 
std::cout << *it;  //3


forward_list: added in C++11
------------------------------
#include <forward_list>
The forward list acts as a singly linked list, so the list can only be traversed in one direction.
The forward list incurs less overhead than the list, but the downside is that we can only use it in one direction.

at and [] - not supported in list. i.e direct access is NOT allowed

std::forward_list<int>  l{1,2,3};
std::forward_list<int> l (10, 100); 
1 = {2, 4,6, 8, 10};

size() not allowed
l.max_size;  // Avery large number

at and [] - not supported in forward list

l.front(); //2
back() not supported 

push_back(6) & pop_back() not available

l.push_front(7);
l.pop_front();

l.emplace_front("Moe", 24); 
emplace_back not supported 

methods that use iterators:
std::forward_list<int>  l{1,2,3,4,5};
auto it = std::find(l.begin(), l.end(), 3);
l.insert_after(it, 10);    // 1 2 3 10 4 5    //note the function is insert_after not insert
l.emplace_after(it, 100);  // 1 2 3 100 10 4 5
l.erase(it);         // 100 erased 1 2 3 10 4 5
l.resize(2);         // 1 2
l.resize(5);         // 1 2  0 0 0 
----------------------------------------------------------------------------------------------------------------
stl::set
--------
Associative containers
Associative containers are collections of stored objects that allow for fast retrieval using a key.
The stl provides both sets and maps.

Depending on the type of the associate container, they're usually implemented behind the scenes as a balanced binary tree, something like a red black tree or as a hash set.

These are very efficient data structures.
So operations on sets and maps are very fast.

The stl has 4 types of set containers.
std::set
std::unordered_set
std::multiset
std::unordered_multiset

#include <set>
std::set

Ordered by key
No duplicate elements
all iterators available and may invalidate (if size shrinks)

std::set - initialization and assignment
std::set<int> s {1, 3, 4, 5, 2};

std::set<std::string> stooges {
				std::string{"Larry"},
				"Moe",
				std::string{"Curly"};

s = {2, 4,6, 7,10};

common methods:
std::set<int> s {4, 5, 1, 2,3,3,2,3};   // 1 2 3 4 5

s.size();  // 5
s.max_size;  // Avery large numbers

No concept of front and back

s. insert (7);   // 1 2 3 4 5 7

common methods:
Person p1 {"Larry", 18};
Person p1 {"Moe", 24};

std:set<Person> stooges;
stooges.insert(p1);     //adds p1 to set stooges
auto result = stooges.insert(p2);     //adds p2 to set stooges

used opertator< for ordering
result returns a std:pair<iterator, bool>
	first is an iterator to the inserted element or to the duplicate in the set	
	second id a boolean indicating succesful or not
	
erase(p2);  //erases p2
it can be used in tandem with sets find (not stdfind)
i.e
	auto it = s.fins(5);
	if (it != s.end())
		s.erase(it);

s.count(1)  //element in the set or not   //0 or 1
s. clear()  // removes all elements
s.empty()   //check if the set is empty - True or false

std::multi_set
---------------
#include<set>

sorted by key

allows duplicate elements

all iterators available

std::unordered_set
-------------------
#include <unordered_set>
elements are unordered

No duplicate elements

elements cannot be modified (must be erased and new element inserted)

No reverse iterators are allowed

std::unordered_multiset
------------------------
#include <unordered_set>
elements are unordered

allows duplicate elements

No reverse iterators are allowed

----------------------------------------------------------------------------------------------------------------
STL Maps containers
--------------------
These are also associative containers.
They're collections of stored objects that allow for fast retrieval using a key.
STl provides both maps and sets
usually implemented as a balanced binary tree or hashset
most operations are efficient

types:
The STL has four types of map containers,
the map,
the unordered-map,
the multimap and
the unordered-multimap.

#include <map>
similar to dictionatu
Elements are stored as Key, value pairs
ordered by key
No diplicate element (keys are unique)
Direct access to to element using key
all iterators available and may invalidate (if size shrinks)


std::map <std::string, int> m1{
	{"Larry", 18},
	{"Moe", 24}
	};

s.size();  // 2
s.max_size;  // A very large numbers

No concept of front and back

insert:
std::pair<std::string, int> p1 {"James", 33};
m.insert(p1);
OR
m.insert(std::make_pair("Curly", 50));

OR using subscript method

m["Frank"] = 40;   //insert
m["Frank"] = 45;   //update
m.at("Frank") = 35;   //update

m.erase("Frank")

m.find("Curly")  //True

m.count("Curly")   // 0 or flase

m.clear()
m.empty()

std::multi_map:
---------------
#include <map>

Ordered by key
Allows duplicate
All iterators are available

std::unordered_map
-------------------
#include <unordered_map>

elements are unordered
No duplicate elements
No reverse iterators are allowed

std::unordered_multimap
------------------------
#include <unordered_map>

elements are unordered
allows duplicate elements
No reverse iterators are allowed
----------------------------------------------------------------------------------------------
STACK:
=======

STL Adaptor container
Last in First out (LIFO) data structure

It's an adapter because it's implemented in terms of already existing STL containers.
Since all operations on a stack happen on only one end, the top.
We can easily implement a stack based on any container that has a back.
These are vector, list, and deque.

So, the way that the stack methods work is they use delegation.
And they call the back, push back, and pop back methods of the underlying container.

All operations occur on one end of the stack

No iterators supported

std::stack
#include <stack>

push (The push method inserts an element at the top of the stack)
pop (The pop method removes an element from the top of the stack.)
top (acces the top element but does not remove it)
empty
size

Since the stack is an adapter class, we can choose what underlying container will be used when we create our stack objects.
The STL will use a deque by default.

std::stack<int> s;      //deque (deafult)
std::stack<int, std::vector<int>> s1;      //vector
std::stack<int, std::list<int>> s2;      //list
std::stack<int, std::deque<int>> s3;      //deque

----------------------------------------------------------------------------------------------
QUEUE:
=======
std::queue
First In First Out Data Structure

Like the stack, the queue is an adapter class because it's implemented in terms of already existing STL containers.
Since operations on the queue happen on both ends, the front and the back, we can easily implement a queue based on any container that has a front and the back.
These are the list and the deque.

Elements are pushed at the back and popped from the fromt

No iterators supported

std::queue
#include <queue>

push (The push method inserts an element at the back of the queue)
pop (The pop method removes an element from the front of the queue.)
front (access the element at the front)
back  (access the element at the back)
empty  (is the queue empty?)
size

Since the queue is an adapter class, we can choose what underlying container will be used when we create our queue objects.
The STL will use a deque by default.

std::queue<int> s;      //deque (deafult)
std::queue<int, std::list<int>> s1;      //list
std::queue<int, std::deque<int>> s3;      //deque

----------------------------------------------------------------------------------------------
PRIORITY QUEUE:
================
std::priority_queue

The priority queue is a container adapter just like the stack and the queue.
The priority queue allows insertions and removal of elements in order from the front of the container.

Elements are stored internally in vectors by default.

Elements are inserted in priority order. So, the largest priority element will always be at the front of the priority queue.
We can insert elements at the front and when we get an element from the front, we're guaranteed that it will be the largest element in the container.

No iterators supported

std::priority_queue
#include <queue>

push (The push method inserts an elementinto sorted order)
pop (The pop method removes top element (greatest).)
top (access the top element(greatest))
empty  (is the queue empty?)
size   (number of elements in the queue)

std::priority_queue<int> pq;   //vector
========================================================================================================================
C++ Enumerations:
-------------------
Also known as enums
introduced in 1970 in Pasacal programming
introdcued in C++11
 
an enumerated type provides a useful way to store a set of named integral constants known as enumerators.
At Enumeration is a user defined data type, the models a set of constant integral values.

The Day of the week
Months of the year
suits in a deck of cards etc.

enum-key enum-name : enumerator-type {};

enum-key  - scoped or unscoped
enum-name - (optional for unscoped)
enumerator-type - type specifier (can be omitted)
{} - enumertor list (explicit or implicit)

enum {Red, Green, Blue};   //Implicit-initialization where the compiler will assign default like red - 0, green - 1 and Blue -2

enum {Red = 1, Green = 2, Blue = 3}; // Explicit initialization

enum {Red = 1, Green , Blue}; // Explicit/Implicit as compiler assigned Green = 2 and Blue = 3 initialization

Named type safe:
enum Color {Red, Green, Blue};   //Should be IS A relation when naming

Color my_color;
my_color = Green;   //Valid
my_color = 4;   //Invalid

Unscoped Enumerations:
----------------------
1. Using if and switch statements //5 or more cases, switch is simplemented as jump table- providinf equal access time for all cases.
2. Using cin and cout 

Scoped Emunerations:
---------------------
scope enumerations that is enumerations, whose enumerators are qualified and therefore they're only visible by using the scope resolution Operator.
This means that if we want to access an enumerations enumerators, we must specify which enumeration the enumerator belongs to.In place of the singular enum, a keyword used to declare us scoped enumerations.

We declare scoped enumerations using the enum class key.
We can also use enum struct and they are both semantically equivalent.

scoped enumerations can sometimes cause issues that can only be resolved by using scoped enumerations.
name clashes, comparing two unequal unamed enuerations

1. Using if and switch statements  //used same as unscoped enums
2. Using cin and cout 

example of scoped enum:
enum class Color {Red =1, Green=2, Blue=3}; 
========================================================================================================================
I/O and Streams:
=================

A stream is  a sequence of bytes.

common stream libraries:
------------------------
Iostream provides the definitions required for formatted input and output to and from streams.
The fstream include file provides definitions for formatted IO to and from file streams.
the iomanip header file provides definitions for manipulators that allow us to format iostreams in specific ways.

stream clasess:
----------------
The ios class provides basic support for formatted and unformatted io. It serves as a base class for most other classes in the iostream hierarchy.
The ifstream class provides high-level input operations from files. So if you want to read from a file, you can declare your object to be an ifstream object.
The ofstream class provides high-level output operations from files.if you want to create a new file or write to a file, you can declare it as an object of ofstream.
The fstream class provides high-level IO on file-based streams. Fstream is derived from ifstream and of osstream using multiple inheritance. we can declare an fstream object to do it.
the stringstream class, this is a very useful class that provides high level io on memory-based strings.

global stream objects:
----------------------
Cin, cout, cerr, and clog are global objects.

They're initialized before main begins to execute and is included in iostream to use them.
Cin is the standard input stream and is by default connected to the keyboard.It's an instance of the istream class.
Cout is the standard output stream, and by default, it's connected to the console.It's an instance of the ostream class.
This class should sound familiar since we used it when we overloaded the insertion operator in the overloading operator section of the course.

Cin and cout are generally buffered streams.
This means that input from cin won't be automatic until the user presses enter.
And output to cout occurs only when the stream buffer fills up or we provide a std endline or we flush the stream.

Now cerr and clog are the standard error stream and the standard log stream, respectively.
They're both unbuffered, which means that we get input or output from them as we need it. Best practice is to use cerr for error messages and clog for log messages.

Stream Manipulators:
---------------------
To help control formatting
can be memeber fucntions or as a manipulators

#include <iomanip>
std::cout.width(10)    //member function
std::cout << std::setw(10)    //manipulator

boolean Manipulators:
---------------------
output of 0/1 ->false/true by setting std::cout << std::boolalpha;
revert by std::cout << std::noboolalpha

method version:
std::cout.setf(std::ios::boolalpha);
std::cout.setf(std::ios::noboolalpha);

reset to default -
std::cout<< std::resetiosflags(std::ios::boolalpha);

Integer Manipulators:
---------------------
default configuration:
	decimal(base 10)
	noshowbase - prefix used to show hexadecimal or octal
	nouppercase - when displaying a prefis and hex vaules will be lower case
	noshowpos - no '+' displayed for positive numbers

Formatting integrers - setting base:
int num {255};
std::cout << std::dec << num <<std::endl;    //255
std::cout << std::hex << num <<std::endl;    //ff
std::cout << std::oct << num <<std::endl;    //377

Formatting integrers - showing base:
int num {255};
std::cout << std::showbase;   //std::noshowbase
std::cout << std::dec << num <<std::endl;    //255
std::cout << std::hex << num <<std::endl;    //0xff
std::cout << std::oct << num <<std::endl;    //0377

Formatting integrers - showing hex in uppercase:
int num {255};
std::cout << std::showbase << std::uppercase;
std::cout << std::hex << num <<std::endl;    //0XFF

Formatting integrers - displaying the positive sign:
int num1 {255};
int num2 {-255};
std::cout << std::showpos;   //std::noshowpos
std::cout << std::dec << num1 <<std::endl;    //+255
std::cout << std::dec << num2 <<std::endl;    //-255

Floating point Stream Manipulators:
------------------------------------
default configuration:
	setprecision(6) - number of digits displayed (mantissa + decimal)
	fixed - not fixed to a specific number of digits after the decimal point
	noshowpoint - trailing zeros not displayed
	nouppercase - when displaying a prefis and hex vaules will be lower case
	noshowpos - no '+' displayed for positive numbers

formatting floating point - precision:
double num {123456789.987654321};
std::cout << std::setprecision(9); // 123456790 and rounded

formatting floating point - fixed:
double num {123456789.987654321};
std::cout << std::fixed);
std::cout << num; // 123456789.987654 // will display precision 6 from the decimal point and rounded // zeros added if necessary

double num {123456789.987654321};
std::cout << std::setprecision(3)  << std::fixed; 
std::cout << num; // 123456789.988   //precision after decimal set to 3 and rounded

formatting floating point - scientific:
double num {123456789.987654321};
std::cout << std::setprecision(3)  << std::scientific; 
std::cout << num;  //1.23e+008

formatting floating point - trailing zeros:
double num {12.34};
std::cout << std::showpoint; 
std::cout << num;  //12.3400   

Align and Fill:
---------------
default configuration:
	setw - not set by default
	left - when no field width, right - when using field width
	fill - not set  by default - blank space is used


Field width - setw:
-------------------
std::cout << std::setw(10) ;   // '  1234.57'  //right justified with width of 10
std::cout << std::setw(10) << std::left   ;   // '1234.57  '  //left justified with width of 10
Also, it only applies to the immediate varialble.

std::cout << <<std::setfill('-');
std::cout  << std::setw(10) << num    //fill works only for the setw
						<< hello <<endl;   //----1234.57Hello   //the setfill and setw only aplies to num not hello 

Reading from a File:
--------------------
fstream and ifstream are commonly used for input files.

basic steps:
------------
#include <fstream>
declare fstream or ifstream object
connect it to a file on your system (open it for reading)
Read data from file via stream
close the stream

opening file with fstream:
-------------------------
std::fstream in_file {"abc.txt", std::ios::in};
in_file -> open file in input mode i.e. read but not write to it 
std::ios::in -> mode and any property of the file. Here -open file in input mode and read

Open file in read only binary mode: useful when reading non-text files cotaining binary data
std::fstream in_file {"abc.exe", std::ios::in | std::ios::binary};    // | bitwise operator

opening file with ifstream:
---------------------------
std::ifstream in_file {"abc.txt", std::ios::in};   //open file in input mode and read
OR
std::ifstream in_file {"abc.txt"};

Open file in binary mode
std::ifstream in_file {"abc.txt", std::ios::binary};

NOTE: ifstream is input file stream which allows you to read the contents of a file.
ofstream is output file stream which allows you to write contents to a file.
fstream allows both reading from and writing to files by default.

Check if file opened succesfully:
--------------------------------- 
is_open
if (in_file.is_open()){
	// DO somthing
} else {
	// file could not open
}
OR
test the stream object
if (in_file()){
	// DO somthing
} else {
	// file could not open
}

closing the file:
------------------
in_file.close();


Reading from the file:
-------------------------
using (>>)
we can use the extraction opertor for formatted read

read an entire line:
std::string line ;
std::getline(in_file, line);

//unformatted 
char c;
std::get(in_file, c);   //reading each char into c variable
 

Write to file:
--------------
--------------
fstream or ofstream are commonly used for output files

basic steps:
------------
#include <fstream>
declare fstream or ofstream object
connect it to a file on your system (open it for writing)
write data into file via stream
close the stream

default write action would be to overwrite, unless apppend mentioned

opening file for writing with fstream:
---------------------------------------
std::fstream out_file {"abc.txt", std::ios::out};
std::ios::out -> mode and any property of the file. Here -open file to write into it and not read

Open file for writing in binary mode
std::fstream out_file {"abc.exe", std::ios::out | std::ios::binary};    

opening file for writing with ofstream:
---------------------------------------
std::ofstream out_file {"abc.txt", std::ios::out};   //open file in output mode and write
OR
std::ofstream out_file {"abc.txt""};

Open file in binary mode
std::ofstream out_file{"abc.txt", std::ios::binary}

std::ofstream out_file {"abc.txt", std::ios::trunc};  //truncate (discard contents) when opening

std::ofstream out_file {"abc.txt", std::ios::app};  //append to each write

std::ofstream out_file {"abc.txt", std::ios::ate};  //file that exists and set the seek to end of stream when opening


Check if file opened succesfully:
--------------------------------- 
is_open
if (out_file.is_open){
	// DO somthing
} else {
	// file could not open
}
OR
test the stream object
if (out_file()){
	// DO somthing
} else {
	// file could not open
}

closing the file:
------------------
out_file.close();

Wreting to  the file:
-------------------------
using (<<)
we can use the extraction opertor for formatted write

int num {100};

out_file << num << "\n" ;    //endl -> flushes out any unwritten buffers


//unformatted 
char c {'w'};
out_line.put( c); 

Strin Streams:
--------------
--------------
Allows us ti read or write from strings in memory much as we would read and write to files

using string streams:
----------------------
stringstream, istringstreams and ostringstream

basic steps:
------------
#include <sstream>
declare stringstream, istringstreams or ostringstream object
connect it to a std::string
Read/write data from/to the string stream using formatted I/O

Reading from a stringstream:
-----------------------------
#include <sstream>
std::string info {"Moe 100 123.45"};
int num {};
double total {};
std::string name {};

std::istringstream iss {info};
iss >> name >> num >> total;

Writing to a stringstream:
-----------------------------
#include <sstream>
int num {100};
double total {123.45};
std::string name {"MOE"};

std::ostringstream oss {};
oss << name << " " << num  << " " << total;
std::cout << oss.str() <<std::endl;


========================================================================================================================
========================================================================================================================
4 types of cast:
----------------
static cast
const cast
dynamic_cast
reinterpret_cast

dynamic_cast is used at run time to find out correct down-cast


reinterpret_cast can perform dangerous conversions because it can typecast any pointer to any pointer
when you want to work with bits


const_cast: can be used to change the const or volatile qualifiers of pointers or references.
const_cast<T> (v)  T must be a pointer, reference or pointer-to-memeber type
When we call 3rd party library where it is taking variable/object as non-const but not changing it.
========================================================================================================================
========================================================================================================================
TODO:
Learn about the program memory - Heap/Free storage, stack, static varialbles, code Area
when to use a pointer vs references?
Multiple threading
Concurrency
==========================================================================
#include <string>
#include <iostream>

std::string trim(const std::string& str) {
    std::string trimmed = str;

    // Trim leading spaces
    size_t start = 0;
    while (start < trimmed.size() && isspace(trimmed[start])) {
        ++start;
    }
    trimmed.erase(0, start);

    // Trim trailing spaces
    size_t end = trimmed.size();
    while (end > 0 && isspace(trimmed[end - 1])) {
        --end;
    }
    trimmed.erase(end);

    return trimmed;
}

int main (){
    
    std::string str = "   hello world   ";
    std::cout << trim(str) << std::endl; // "hello world"

    return 0;    
}
==============================================================================